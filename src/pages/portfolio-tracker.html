<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker Pro - Digital Brokerage</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link rel="stylesheet" href="../styles/main.css">
    <style>
        /* BROKERAGE INTERFACE STYLES */
        .brokerage-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0;
        }

        .portfolio-header {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 25px;
            margin-bottom: 30px;
        }

        .portfolio-overview {
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(0, 0, 0, 1) 100%),
                linear-gradient(45deg, rgba(0, 255, 136, 0.08) 0%, transparent 50%, rgba(255, 51, 102, 0.04) 100%);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            padding: 40px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.8),
                0 0 0 1px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .portfolio-overview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 255, 136, 0.8) 20%, 
                rgba(255, 255, 255, 1) 50%, 
                rgba(255, 51, 102, 0.8) 80%, 
                transparent 100%);
            animation: brokerageGlow 4s ease-in-out infinite;
        }

        @keyframes brokerageGlow {
            0%, 100% { 
                opacity: 0.6; 
                transform: scaleX(1);
            }
            50% { 
                opacity: 1; 
                transform: scaleX(1.1);
            }
        }

        .portfolio-value {
            font-size: 3.5em;
            font-weight: 100;
            color: #ffffff;
            margin-bottom: 10px;
            letter-spacing: -2px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .portfolio-change {
            font-size: 1.2em;
            margin-bottom: 20px;
            font-weight: 200;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .change-indicator {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .change-positive {
            background: rgba(0, 255, 136, 0.15);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .change-negative {
            background: rgba(255, 51, 102, 0.15);
            color: #ff3366;
            border: 1px solid rgba(255, 51, 102, 0.3);
        }

        .portfolio-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 25px;
        }

        .metric-item {
            text-align: center;
            padding: 15px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .metric-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
        }

        .metric-label {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 1.4em;
            font-weight: 200;
            color: #ffffff;
        }

        .portfolio-chart {
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 1) 100%),
                linear-gradient(45deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            height: 300px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.7),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .chart-title {
            font-size: 1em;
            font-weight: 300;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .holdings-section {
            margin-bottom: 30px;
        }

        .holdings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }

        .holding-card {
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 1) 100%),
                linear-gradient(45deg, rgba(0, 255, 136, 0.03) 0%, transparent 50%, rgba(255, 51, 102, 0.02) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 25px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .holding-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: rgba(0, 255, 136, 0.4);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .holding-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .holding-symbol {
            font-size: 1.4em;
            font-weight: 300;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .holding-price {
            text-align: right;
        }

        .current-price {
            font-size: 1.3em;
            font-weight: 200;
            color: #ffffff;
            margin-bottom: 5px;
        }

        .price-change {
            font-size: 0.9em;
            font-weight: 300;
        }

        .holding-chart {
            height: 80px;
            margin: 20px 0;
            position: relative;
        }

        .holding-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .detail-item {
            text-align: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .detail-label {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .detail-value {
            font-size: 1em;
            font-weight: 200;
            color: #ffffff;
        }

        .add-position-card {
            background: 
                linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 0, 0, 1) 100%),
                linear-gradient(45deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
            border: 2px dashed rgba(0, 255, 136, 0.3);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s ease;
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 280px;
        }

        .add-position-card:hover {
            background: 
                linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 0, 0, 1) 100%);
            border-color: rgba(0, 255, 136, 0.6);
            transform: translateY(-4px);
            box-shadow: 0 15px 40px rgba(0, 255, 136, 0.1);
        }

        .add-icon {
            font-size: 3em;
            color: rgba(0, 255, 136, 0.6);
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .add-position-card:hover .add-icon {
            color: rgba(0, 255, 136, 1);
            transform: scale(1.1);
        }

        .add-text {
            font-size: 1.1em;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Autocomplete Styles */
        .symbol-input-container {
            position: relative;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.98);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .symbol-main {
            font-weight: bold;
            color: #ffffff;
            font-size: 0.9em;
        }

        .symbol-name {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8em;
            margin-top: 2px;
        }

        .symbol-price {
            color: #00ff88;
            font-size: 0.8em;
            font-weight: bold;
        }

        .loading-indicator {
            padding: 12px 15px;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8em;
        }

        /* ALIEN RISK ANALYZER - FUNÇÃO SURPRESA ÉPICA */
        .risk-analyzer-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 9999;
        }

        .risk-analyzer-toggle {
            width: 80px;
            height: 80px;
            background: 
                radial-gradient(circle at 30% 30%, rgba(0, 255, 136, 0.8) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(255, 51, 102, 0.6) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 1) 100%);
            border: 3px solid rgba(0, 255, 136, 0.4);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            color: #00ff88;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: riskPulse 3s ease-in-out infinite;
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.3),
                0 0 60px rgba(0, 255, 136, 0.1),
                inset 0 0 20px rgba(0, 255, 136, 0.1);
        }

        .risk-analyzer-toggle:hover {
            transform: scale(1.1) rotate(15deg);
            border-color: rgba(0, 255, 136, 0.8);
            box-shadow: 
                0 0 50px rgba(0, 255, 136, 0.5),
                0 0 100px rgba(0, 255, 136, 0.2),
                inset 0 0 30px rgba(0, 255, 136, 0.2);
        }

        @keyframes riskPulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                border-color: rgba(0, 255, 136, 0.4);
            }
            50% { 
                transform: scale(1.05) rotate(10deg);
                border-color: rgba(0, 255, 136, 0.8);
            }
        }

        .risk-analyzer-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 90vw;
            max-width: 1200px;
            height: 80vh;
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(0, 0, 0, 1) 100%),
                linear-gradient(45deg, rgba(0, 255, 136, 0.08) 0%, transparent 50%, rgba(255, 51, 102, 0.05) 100%);
            border: 3px solid rgba(0, 255, 136, 0.4);
            border-radius: 25px;
            backdrop-filter: blur(20px);
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            box-shadow: 
                0 50px 150px rgba(0, 0, 0, 0.9),
                0 0 0 1px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .risk-analyzer-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .risk-analyzer-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 255, 136, 0.8) 25%, 
                rgba(255, 255, 255, 1) 50%, 
                rgba(255, 51, 102, 0.8) 75%, 
                transparent 100%);
            animation: alienScanLine 3s ease-in-out infinite;
        }

        @keyframes alienScanLine {
            0%, 100% { 
                transform: translateX(-100%);
                opacity: 0.6;
            }
            50% { 
                transform: translateX(100%);
                opacity: 1;
            }
        }

        .risk-analyzer-header {
            padding: 30px;
            border-bottom: 2px solid rgba(0, 255, 136, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .risk-analyzer-title {
            font-size: 1.8em;
            font-weight: 200;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #00ff88, #ffffff, #ff3366);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .risk-analyzer-close {
            width: 40px;
            height: 40px;
            background: rgba(255, 51, 102, 0.1);
            border: 2px solid rgba(255, 51, 102, 0.3);
            border-radius: 50%;
            color: #ff3366;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
        }

        .risk-analyzer-close:hover {
            background: rgba(255, 51, 102, 0.2);
            border-color: rgba(255, 51, 102, 0.6);
            transform: scale(1.1);
        }

        .risk-analyzer-content {
            padding: 30px;
            height: calc(100% - 120px);
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .risk-metrics-section {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            gap: 20px;
        }

        .risk-metric-card {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(0, 255, 136, 0.2);
            border-radius: 15px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .risk-metric-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 255, 136, 0.1);
        }

        .risk-metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.8), transparent);
            animation: riskCardGlow 2s ease-in-out infinite;
        }

        @keyframes riskCardGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .risk-metric-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .risk-metric-value {
            font-size: 2.5em;
            font-weight: 200;
            margin-bottom: 5px;
        }

        .risk-metric-status {
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .risk-low { color: #00ff88; }
        .risk-medium { color: #ffaa00; }
        .risk-high { color: #ff3366; }

        .risk-visualization {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(0, 255, 136, 0.2);
            border-radius: 15px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .risk-chart-container {
            height: 300px;
            position: relative;
        }

        .alien-alerts {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .alien-alert {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
            animation: alertPulse 2s ease-in-out infinite;
        }

        .alien-alert.warning {
            background: rgba(255, 170, 0, 0.05);
            border-color: rgba(255, 170, 0, 0.3);
        }

        .alien-alert.danger {
            background: rgba(255, 51, 102, 0.05);
            border-color: rgba(255, 51, 102, 0.3);
        }

        @keyframes alertPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .alert-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        }

        .alert-message {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
        }

        .position-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(0, 0, 0, 1) 100%),
                linear-gradient(45deg, rgba(0, 255, 136, 0.05) 0%, transparent 50%, rgba(255, 51, 102, 0.03) 100%);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 500px;
            position: relative;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 30px 80px rgba(0, 0, 0, 0.8),
                0 0 0 1px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-size: 1.3em;
            font-weight: 300;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            padding-bottom: 15px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 200;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-input {
            width: 100%;
            padding: 15px 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            font-size: 1em;
            background: 
                linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.95) 100%);
            color: #ffffff;
            transition: all 0.4s ease;
            font-weight: 200;
            backdrop-filter: blur(10px);
        }

        .form-input:focus {
            outline: none;
            border-color: rgba(0, 255, 136, 0.6);
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.2),
                0 8px 25px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .modal-btn {
            flex: 1;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 200;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: 1px solid;
        }

        .btn-primary {
            background: 
                linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.05) 100%);
            color: #00ff88;
            border-color: rgba(0, 255, 136, 0.3);
        }

        .btn-primary:hover {
            background: 
                linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 255, 136, 0.1) 100%);
            border-color: rgba(0, 255, 136, 0.6);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            color: #ff3366;
            transform: scale(1.2);
        }

        /* RESPONSIVE */
        @media (max-width: 1200px) {
            .portfolio-header {
                grid-template-columns: 1fr;
            }
            
            .portfolio-metrics {
                grid-template-columns: 1fr;
            }
            
            .holdings-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .portfolio-overview {
                padding: 25px;
            }
            
            .portfolio-value {
                font-size: 2.5em;
            }
            
            .holding-card {
                padding: 20px;
            }
            
            .modal-content {
                padding: 30px 25px;
            }
            
            .portfolio-metrics {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-button">◄ Back to Menu</a>
    <div class="container">
        <div class="header">
            <h1>Portfolio Tracker Pro</h1>
            <p>Digital Brokerage Interface</p>
        </div>

        <div class="brokerage-container">
            <!-- Portfolio Header -->
            <div class="portfolio-header">
                <div class="portfolio-overview">
                    <div class="portfolio-value" id="totalPortfolioValue">$0.00</div>
                    <div class="portfolio-change">
                        <span id="portfolioChangeValue">+$0.00</span>
                        <span class="change-indicator change-positive" id="portfolioChangePercent">+0.00%</span>
                    </div>
                    
                    <div class="portfolio-metrics">
                        <div class="metric-item">
                            <div class="metric-label">Day Change</div>
                            <div class="metric-value" id="dayChange">$0.00</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Total Return</div>
                            <div class="metric-value" id="totalReturn">0.00%</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Positions</div>
                            <div class="metric-value" id="positionCount">0</div>
                        </div>
                    </div>
                </div>
                
                <div class="portfolio-chart">
                    <div class="chart-title">Portfolio Performance</div>
                    <canvas id="portfolioChart"></canvas>
                </div>
            </div>

            <!-- Holdings Section -->
            <div class="holdings-section">
                <div class="holdings-grid" id="holdingsGrid">
                    <!-- Add Position Card -->
                    <div class="add-position-card" onclick="openPositionModal()">
                        <div class="add-icon">+</div>
                        <div class="add-text">Add Position</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Position Modal -->
    <div class="position-modal" id="positionModal">
        <div class="modal-content">
            <button class="close-modal" onclick="closePositionModal()">&times;</button>
            <div class="modal-title">Add New Position</div>
            
                <form id="positionForm">
                    <div class="form-group">
                        <label class="form-label">Symbol *</label>
                        <div class="symbol-input-container">
                            <input type="text" class="form-input" id="symbolInput" placeholder="Search AAPL, MSFT, BTC-USD..." required autocomplete="off">
                            <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                        </div>
                    </div>                <div class="form-group">
                    <label class="form-label">Shares</label>
                    <input type="number" class="form-input" id="sharesInput" step="0.000001" placeholder="100" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Average Price</label>
                    <input type="number" class="form-input" id="avgPriceInput" step="0.01" placeholder="150.00" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Current Price</label>
                    <input type="number" class="form-input" id="currentPriceInput" step="0.01" placeholder="155.00" required>
                </div>
                
                <div class="modal-buttons">
                    <button type="button" class="modal-btn btn-secondary" onclick="closePositionModal()">Cancel</button>
                    <button type="submit" class="modal-btn btn-primary">Add Position</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ALIEN RISK ANALYZER - FUNÇÃO SURPRESA ÉPICA -->
    <div class="risk-analyzer-container">
        <div class="risk-analyzer-toggle" onclick="toggleRiskAnalyzer()">
            🛸
        </div>
    </div>

    <div class="risk-analyzer-panel" id="riskAnalyzerPanel">
        <div class="risk-analyzer-header">
            <div class="risk-analyzer-title">Alien Risk Analyzer</div>
            <div class="risk-analyzer-close" onclick="closeRiskAnalyzer()">×</div>
        </div>
        <div class="risk-analyzer-content">
            <div class="risk-metrics-section">
                <div class="risk-metric-card">
                    <div class="risk-metric-label">Portfolio Risk Score</div>
                    <div class="risk-metric-value risk-medium" id="portfolioRiskScore">7.2</div>
                    <div class="risk-metric-status risk-medium" id="portfolioRiskStatus">Moderate Risk</div>
                </div>
                
                <div class="risk-metric-card">
                    <div class="risk-metric-label">Volatility Index</div>
                    <div class="risk-metric-value risk-low" id="volatilityIndex">24.5%</div>
                    <div class="risk-metric-status risk-low" id="volatilityStatus">Low Volatility</div>
                </div>
                
                <div class="risk-metric-card">
                    <div class="risk-metric-label">Correlation Risk</div>
                    <div class="risk-metric-value risk-high" id="correlationRisk">0.84</div>
                    <div class="risk-metric-status risk-high" id="correlationStatus">High Correlation</div>
                </div>
            </div>
            
            <div class="risk-visualization">
                <div class="risk-chart-container">
                    <canvas id="riskAnalysisChart"></canvas>
                </div>
                
                <div class="alien-alerts" id="alienAlerts">
                    <div class="alien-alert warning">
                        <div class="alert-title">⚠️ High Correlation Detected</div>
                        <div class="alert-message">Your AAPL and MSFT positions move together. Consider diversification.</div>
                    </div>
                    
                    <div class="alien-alert">
                        <div class="alert-title">🎯 Optimization Opportunity</div>
                        <div class="alert-message">Adding bonds could reduce risk by 15% with minimal return impact.</div>
                    </div>
                    
                    <div class="alien-alert danger">
                        <div class="alert-title">🚨 Concentration Risk</div>
                        <div class="alert-message">70% of portfolio in tech stocks. Consider rebalancing.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BrokeragePortfolio {
            constructor() {
                this.positions = JSON.parse(localStorage.getItem('brokeragePositions')) || [
                    // Dados de exemplo com preços atualizados para Janeiro 2025
                    {
                        id: 1,
                        symbol: 'AAPL',
                        shares: 50,
                        avgPrice: 180.00,
                        currentPrice: 225.80,
                        priceHistory: this.generatePriceHistory(180.00, 225.80, 30)
                    },
                    {
                        id: 2,
                        symbol: 'TSLA',
                        shares: 15,
                        avgPrice: 220.00,
                        currentPrice: 248.50,
                        priceHistory: this.generatePriceHistory(220.00, 248.50, 30)
                    },
                    {
                        id: 3,
                        symbol: 'MSFT',
                        shares: 25,
                        avgPrice: 380.00,
                        currentPrice: 445.75,
                        priceHistory: this.generatePriceHistory(380.00, 445.75, 30)
                    }
                ];
                this.searchCache = new Map();
                this.searchTimeout = null;
                this.selectedIndex = -1;
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.updatePortfolioMetrics();
                this.renderHoldings();
                this.setupPortfolioChart();
                this.setupAutocomplete();
                this.initializeRiskAnalyzer();
                this.startPriceUpdates();
            }

            startPriceUpdates() {
                // Atualiza preços a cada 2 minutos
                setInterval(async () => {
                    await this.updateAllPrices();
                }, 120000);

                // Primeira atualização após 10 segundos
                setTimeout(async () => {
                    await this.updateAllPrices();
                }, 10000);
            }

            async updateAllPrices() {
                let updated = false;
                
                for (const position of this.positions) {
                    try {
                        const newPrice = await this.fetchRealTimePrice(position.symbol);
                        if (newPrice && Math.abs(newPrice - position.currentPrice) > 0.01) {
                            position.currentPrice = newPrice;
                            updated = true;
                            
                            // Adiciona ponto ao histórico
                            const now = new Date();
                            position.priceHistory.push({
                                date: now.toISOString().split('T')[0],
                                price: newPrice
                            });
                            
                            // Mantém apenas últimos 30 dias
                            if (position.priceHistory.length > 30) {
                                position.priceHistory = position.priceHistory.slice(-30);
                            }
                        }
                    } catch (error) {
                        console.log(`Price update failed for ${position.symbol}:`, error);
                    }
                }
                
                if (updated) {
                    this.savePositions();
                    this.updatePortfolioMetrics();
                    this.renderHoldings();
                    this.setupPortfolioChart();
                    this.updateRiskMetrics();
                    
                    // Mostra notificação discreta
                    this.showPriceUpdateNotification();
                }
            }

            showPriceUpdateNotification() {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(0, 255, 136, 0.1);
                    border: 1px solid rgba(0, 255, 136, 0.3);
                    color: #00ff88;
                    padding: 10px 20px;
                    border-radius: 8px;
                    font-size: 0.9em;
                    z-index: 10000;
                    animation: fadeInOut 3s ease-in-out forwards;
                `;
                notification.textContent = '💎 Prices Updated';
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateX(100%); }
                        20%, 80% { opacity: 1; transform: translateX(0); }
                        100% { opacity: 0; transform: translateX(100%); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    document.body.removeChild(notification);
                    document.head.removeChild(style);
                }, 3000);
            }

            initializeRiskAnalyzer() {
                this.riskAnalyzerActive = false;
                this.riskChart = null;
                this.setupRiskAnalysisChart();
                this.updateRiskMetrics();
                
                // Auto-update risk metrics every 30 seconds
                setInterval(() => {
                    if (this.riskAnalyzerActive) {
                        this.updateRiskMetrics();
                        this.generateAlienAlerts();
                    }
                }, 30000);
            }

            toggleRiskAnalyzer() {
                const panel = document.getElementById('riskAnalyzerPanel');
                this.riskAnalyzerActive = !this.riskAnalyzerActive;
                
                if (this.riskAnalyzerActive) {
                    panel.classList.add('active');
                    this.updateRiskMetrics();
                    this.setupRiskAnalysisChart();
                    this.generateAlienAlerts();
                } else {
                    panel.classList.remove('active');
                }
            }

            closeRiskAnalyzer() {
                const panel = document.getElementById('riskAnalyzerPanel');
                panel.classList.remove('active');
                this.riskAnalyzerActive = false;
            }

            updateRiskMetrics() {
                if (this.positions.length === 0) return;

                // Calculate portfolio risk score (0-10)
                const riskScore = this.calculatePortfolioRisk();
                const volatility = this.calculateVolatility();
                const correlation = this.calculateCorrelation();

                // Update UI
                document.getElementById('portfolioRiskScore').textContent = riskScore.toFixed(1);
                document.getElementById('portfolioRiskScore').className = `risk-metric-value ${this.getRiskClass(riskScore)}`;
                document.getElementById('portfolioRiskStatus').textContent = this.getRiskLabel(riskScore);
                document.getElementById('portfolioRiskStatus').className = `risk-metric-status ${this.getRiskClass(riskScore)}`;

                document.getElementById('volatilityIndex').textContent = `${volatility.toFixed(1)}%`;
                document.getElementById('volatilityIndex').className = `risk-metric-value ${this.getVolatilityClass(volatility)}`;
                document.getElementById('volatilityStatus').textContent = this.getVolatilityLabel(volatility);
                document.getElementById('volatilityStatus').className = `risk-metric-status ${this.getVolatilityClass(volatility)}`;

                document.getElementById('correlationRisk').textContent = correlation.toFixed(2);
                document.getElementById('correlationRisk').className = `risk-metric-value ${this.getCorrelationClass(correlation)}`;
                document.getElementById('correlationStatus').textContent = this.getCorrelationLabel(correlation);
                document.getElementById('correlationStatus').className = `risk-metric-status ${this.getCorrelationClass(correlation)}`;
            }

            calculatePortfolioRisk() {
                // Sophisticated risk calculation based on position concentration, volatility, and sector exposure
                const totalValue = this.positions.reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0);
                
                // Concentration risk (Herfindahl index)
                const weights = this.positions.map(pos => (pos.shares * pos.currentPrice) / totalValue);
                const concentration = weights.reduce((sum, w) => sum + w * w, 0);
                
                // Sector concentration (simplified - tech vs non-tech)
                const techSymbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'AMD', 'NFLX', 'ADBE'];
                const techWeight = this.positions
                    .filter(pos => techSymbols.includes(pos.symbol))
                    .reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0) / totalValue;
                
                // Price volatility estimation
                let avgVolatility = 0;
                this.positions.forEach(pos => {
                    const priceChange = Math.abs((pos.currentPrice - pos.avgPrice) / pos.avgPrice);
                    avgVolatility += priceChange * ((pos.shares * pos.currentPrice) / totalValue);
                });

                // Combine factors (0-10 scale)
                const concentrationRisk = Math.min(concentration * 10, 4);
                const sectorRisk = Math.min(techWeight * 3, 3);
                const volatilityRisk = Math.min(avgVolatility * 20, 3);
                
                return concentrationRisk + sectorRisk + volatilityRisk;
            }

            calculateVolatility() {
                if (this.positions.length === 0) return 0;
                
                let weightedVolatility = 0;
                const totalValue = this.positions.reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0);
                
                this.positions.forEach(pos => {
                    const weight = (pos.shares * pos.currentPrice) / totalValue;
                    const priceChange = Math.abs((pos.currentPrice - pos.avgPrice) / pos.avgPrice);
                    const annualizedVol = priceChange * Math.sqrt(252) * 100; // Annualized volatility
                    weightedVolatility += weight * Math.min(annualizedVol, 100);
                });
                
                return weightedVolatility;
            }

            calculateCorrelation() {
                // Simplified correlation based on sector similarity
                if (this.positions.length < 2) return 0;
                
                const techSymbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'AMD', 'NFLX', 'ADBE'];
                const techPositions = this.positions.filter(pos => techSymbols.includes(pos.symbol));
                const totalValue = this.positions.reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0);
                const techValue = techPositions.reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0);
                
                return techValue / totalValue;
            }

            getRiskClass(score) {
                if (score <= 3) return 'risk-low';
                if (score <= 6) return 'risk-medium';
                return 'risk-high';
            }

            getRiskLabel(score) {
                if (score <= 3) return 'Low Risk';
                if (score <= 6) return 'Moderate Risk';
                return 'High Risk';
            }

            getVolatilityClass(vol) {
                if (vol <= 20) return 'risk-low';
                if (vol <= 40) return 'risk-medium';
                return 'risk-high';
            }

            getVolatilityLabel(vol) {
                if (vol <= 20) return 'Low Volatility';
                if (vol <= 40) return 'Moderate Volatility';
                return 'High Volatility';
            }

            getCorrelationClass(corr) {
                if (corr <= 0.3) return 'risk-low';
                if (corr <= 0.6) return 'risk-medium';
                return 'risk-high';
            }

            getCorrelationLabel(corr) {
                if (corr <= 0.3) return 'Low Correlation';
                if (corr <= 0.6) return 'Moderate Correlation';
                return 'High Correlation';
            }

            setupRiskAnalysisChart() {
                const canvas = document.getElementById('riskAnalysisChart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                
                if (this.riskChart) {
                    this.riskChart.destroy();
                }

                // Create risk vs return scatter plot with bubble sizes
                const data = this.positions.map(pos => {
                    const totalValue = pos.shares * pos.currentPrice;
                    const returnPct = ((pos.currentPrice - pos.avgPrice) / pos.avgPrice) * 100;
                    const risk = Math.abs(returnPct) + Math.random() * 10; // Simulated risk metric
                    
                    return {
                        x: risk,
                        y: returnPct,
                        r: Math.sqrt(totalValue / 1000), // Bubble size based on position size
                        symbol: pos.symbol
                    };
                });

                this.riskChart = new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: 'Risk vs Return',
                            data: data,
                            backgroundColor: data.map(d => d.y >= 0 ? 'rgba(0, 255, 136, 0.6)' : 'rgba(255, 51, 102, 0.6)'),
                            borderColor: data.map(d => d.y >= 0 ? '#00ff88' : '#ff3366'),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const point = context.raw;
                                        return `${point.symbol}: Risk ${point.x.toFixed(1)}, Return ${point.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Risk Level',
                                    color: '#ffffff'
                                },
                                grid: { color: 'rgba(0, 255, 136, 0.1)' },
                                ticks: { color: '#ffffff' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Return (%)',
                                    color: '#ffffff'
                                },
                                grid: { color: 'rgba(0, 255, 136, 0.1)' },
                                ticks: { color: '#ffffff' }
                            }
                        }
                    }
                });
            }

            generateAlienAlerts() {
                const alertsContainer = document.getElementById('alienAlerts');
                const alerts = [];
                
                // Analyze portfolio and generate intelligent alerts
                const riskScore = this.calculatePortfolioRisk();
                const correlation = this.calculateCorrelation();
                const totalValue = this.positions.reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0);
                
                // Concentration alerts
                this.positions.forEach(pos => {
                    const weight = (pos.shares * pos.currentPrice) / totalValue;
                    if (weight > 0.4) {
                        alerts.push({
                            type: 'danger',
                            title: '🚨 Position Concentration Alert',
                            message: `${pos.symbol} represents ${(weight * 100).toFixed(1)}% of your portfolio. Consider reducing exposure.`
                        });
                    }
                });

                // Correlation alerts
                if (correlation > 0.7) {
                    alerts.push({
                        type: 'warning',
                        title: '⚠️ High Correlation Detected',
                        message: 'Your positions are highly correlated. Consider diversifying across sectors.'
                    });
                }

                // Performance alerts
                const losers = this.positions.filter(pos => pos.currentPrice < pos.avgPrice * 0.9);
                if (losers.length > 0) {
                    alerts.push({
                        type: 'warning',
                        title: '📉 Underperforming Assets',
                        message: `${losers.length} positions are down >10%. Review stop-loss strategies.`
                    });
                }

                // Opportunity alerts
                if (riskScore < 4) {
                    alerts.push({
                        type: 'info',
                        title: '🎯 Growth Opportunity',
                        message: 'Low risk detected. Consider adding growth assets to improve returns.'
                    });
                }

                // Render alerts
                alertsContainer.innerHTML = alerts.slice(0, 4).map(alert => `
                    <div class="alien-alert ${alert.type}">
                        <div class="alert-title">${alert.title}</div>
                        <div class="alert-message">${alert.message}</div>
                    </div>
                `).join('');
            }

            setupAutocomplete() {
                const symbolInput = document.getElementById('symbolInput');
                const dropdown = document.getElementById('autocompleteDropdown');

                symbolInput.addEventListener('input', (e) => {
                    const query = e.target.value.trim();
                    if (query.length >= 1) {
                        this.searchSymbols(query);
                    } else {
                        this.hideDropdown();
                    }
                });

                symbolInput.addEventListener('keydown', (e) => {
                    const items = dropdown.querySelectorAll('.autocomplete-item');
                    
                    switch(e.key) {
                        case 'ArrowDown':
                            e.preventDefault();
                            this.selectedIndex = Math.min(this.selectedIndex + 1, items.length - 1);
                            this.updateSelection();
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
                            this.updateSelection();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (this.selectedIndex >= 0 && items[this.selectedIndex]) {
                                this.selectSymbol(items[this.selectedIndex]);
                            }
                            break;
                        case 'Escape':
                            this.hideDropdown();
                            break;
                    }
                });

                // Hide dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!symbolInput.contains(e.target) && !dropdown.contains(e.target)) {
                        this.hideDropdown();
                    }
                });
            }

            async searchSymbols(query) {
                clearTimeout(this.searchTimeout);
                
                this.searchTimeout = setTimeout(async () => {
                    const dropdown = document.getElementById('autocompleteDropdown');
                    
                    // Check cache first
                    if (this.searchCache.has(query.toLowerCase())) {
                        this.showResults(this.searchCache.get(query.toLowerCase()));
                        return;
                    }

                    // Show loading
                    dropdown.innerHTML = '<div class="loading-indicator">Searching...</div>';
                    dropdown.style.display = 'block';

                    try {
                        // Fallback to predefined symbols for localhost compatibility
                        const predefinedSymbols = this.getPredefinedSymbols(query);
                        
                        if (predefinedSymbols.length > 0) {
                            // Get current prices for predefined results
                            await this.enrichWithPricesOffline(predefinedSymbols);
                            
                            // Cache results
                            this.searchCache.set(query.toLowerCase(), predefinedSymbols);
                            
                            this.showResults(predefinedSymbols);
                        } else {
                            dropdown.innerHTML = '<div class="no-results">No matches found. Try: AAPL, TSLA, MSFT, BTC-USD</div>';
                        }
                        
                    } catch (error) {
                        console.error('Search error:', error);
                        dropdown.innerHTML = '<div class="no-results">Search temporarily unavailable</div>';
                    }
                }, 300); // Debounce 300ms
            }

            getPredefinedSymbols(query) {
                // Preços atualizados para Janeiro 2025
                const symbolDatabase = [
                    { symbol: 'AAPL', name: 'Apple Inc.', type: 'STOCK', price: 225.80 },
                    { symbol: 'MSFT', name: 'Microsoft Corporation', type: 'STOCK', price: 445.75 },
                    { symbol: 'TSLA', name: 'Tesla Inc.', type: 'STOCK', price: 248.50 },
                    { symbol: 'GOOGL', name: 'Alphabet Inc.', type: 'STOCK', price: 185.90 },
                    { symbol: 'AMZN', name: 'Amazon.com Inc.', type: 'STOCK', price: 195.25 },
                    { symbol: 'NVDA', name: 'NVIDIA Corporation', type: 'STOCK', price: 145.60 },
                    { symbol: 'META', name: 'Meta Platforms Inc.', type: 'STOCK', price: 598.75 },
                    { symbol: 'AMD', name: 'Advanced Micro Devices', type: 'STOCK', price: 122.30 },
                    { symbol: 'NFLX', name: 'Netflix Inc.', type: 'STOCK', price: 895.40 },
                    { symbol: 'ADBE', name: 'Adobe Inc.', type: 'STOCK', price: 485.60 },
                    { symbol: 'CRM', name: 'Salesforce Inc.', type: 'STOCK', price: 335.20 },
                    { symbol: 'ORCL', name: 'Oracle Corporation', type: 'STOCK', price: 185.40 },
                    { symbol: 'BTC-USD', name: 'Bitcoin USD', type: 'CRYPTO', price: 105750.00 },
                    { symbol: 'ETH-USD', name: 'Ethereum USD', type: 'CRYPTO', price: 3890.25 },
                    { symbol: 'ADA-USD', name: 'Cardano USD', type: 'CRYPTO', price: 1.15 },
                    { symbol: 'SOL-USD', name: 'Solana USD', type: 'CRYPTO', price: 245.80 },
                    { symbol: 'DOGE-USD', name: 'Dogecoin USD', type: 'CRYPTO', price: 0.385 },
                    { symbol: 'SPY', name: 'SPDR S&P 500 ETF', type: 'ETF', price: 598.45 },
                    { symbol: 'QQQ', name: 'Invesco QQQ Trust', type: 'ETF', price: 525.30 },
                    { symbol: 'VTI', name: 'Vanguard Total Stock Market', type: 'ETF', price: 295.60 }
                ];

                const queryLower = query.toLowerCase();
                return symbolDatabase.filter(item => 
                    item.symbol.toLowerCase().includes(queryLower) ||
                    item.name.toLowerCase().includes(queryLower)
                ).slice(0, 8);
            }

            async enrichWithPricesOffline(results) {
                // Tenta buscar preços reais primeiro, se falhar usa preços base com variação
                for (const result of results) {
                    try {
                        // Tenta buscar preço real
                        const realPrice = await this.fetchRealTimePrice(result.symbol);
                        if (realPrice) {
                            result.price = realPrice;
                            result.isRealTime = true;
                        } else {
                            // Fallback: preço base com variação realista
                            const variation = (Math.random() - 0.5) * 0.04; // ±2% variation
                            result.price = result.price * (1 + variation);
                            result.isRealTime = false;
                        }
                        result.currency = 'USD';
                        result.lastUpdate = new Date().toLocaleTimeString();
                    } catch (error) {
                        // Se der erro, usa preço base com pequena variação
                        const variation = (Math.random() - 0.5) * 0.02;
                        result.price = result.price * (1 + variation);
                        result.isRealTime = false;
                    }
                }
            }

            async fetchRealTimePrice(symbol) {
                try {
                    // Múltiplas tentativas de APIs diferentes
                    const apis = [
                        `https://api.coingecko.com/api/v3/simple/price?ids=${this.getCoingeckoId(symbol)}&vs_currencies=usd`,
                        `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbol}`,
                        `https://api.polygon.io/v2/aggs/ticker/${symbol}/prev?adjusted=true&apikey=demo`
                    ];

                    for (const apiUrl of apis) {
                        try {
                            const response = await fetch(apiUrl);
                            if (response.ok) {
                                const data = await response.json();
                                const price = this.extractPrice(data, symbol, apiUrl);
                                if (price) return price;
                            }
                        } catch (apiError) {
                            continue; // Tenta próxima API
                        }
                    }
                    
                    return null;
                } catch (error) {
                    return null;
                }
            }

            getCoingeckoId(symbol) {
                const cryptoMap = {
                    'BTC-USD': 'bitcoin',
                    'ETH-USD': 'ethereum',
                    'ADA-USD': 'cardano',
                    'SOL-USD': 'solana',
                    'DOGE-USD': 'dogecoin'
                };
                return cryptoMap[symbol] || symbol.toLowerCase();
            }

            extractPrice(data, symbol, apiUrl) {
                try {
                    if (apiUrl.includes('coingecko')) {
                        const coinId = this.getCoingeckoId(symbol);
                        return data[coinId]?.usd;
                    } else if (apiUrl.includes('yahoo')) {
                        return data.quoteResponse?.result?.[0]?.regularMarketPrice;
                    } else if (apiUrl.includes('polygon')) {
                        return data.results?.[0]?.c;
                    }
                    return null;
                } catch (error) {
                    return null;
                }
            }

            getAssetType(quote) {
                const type = quote.quoteType?.toLowerCase() || '';
                const symbol = quote.symbol?.toLowerCase() || '';
                
                if (type === 'cryptocurrency' || symbol.includes('-usd') || symbol.includes('btc') || symbol.includes('eth')) {
                    return 'CRYPTO';
                } else if (type === 'etf') {
                    return 'ETF';
                } else if (type === 'mutualfund') {
                    return 'FUND';
                } else {
                    return 'STOCK';
                }
            }

            async enrichWithPrices(results) {
                if (results.length === 0) return;

                try {
                    const symbols = results.map(r => r.symbol).join(',');
                    const response = await fetch(`https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbols}`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const quotes = data.quoteResponse?.result || [];
                        
                        results.forEach(result => {
                            const quote = quotes.find(q => q.symbol === result.symbol);
                            if (quote) {
                                result.price = quote.regularMarketPrice || quote.price || null;
                                result.currency = quote.currency || 'USD';
                            }
                        });
                    }
                } catch (error) {
                    console.error('Price fetch error:', error);
                }
            }

            showResults(results) {
                const dropdown = document.getElementById('autocompleteDropdown');
                this.selectedIndex = -1;

                if (results.length === 0) {
                    dropdown.innerHTML = '<div class="no-results">No results found</div>';
                    dropdown.style.display = 'block';
                    return;
                }

                const html = results.map((result, index) => `
                    <div class="autocomplete-item" data-symbol="${result.symbol}" data-name="${result.name}" data-price="${result.price || ''}" onclick="selectSymbol(this)">
                        <div>
                            <div class="symbol-main">${result.symbol} 
                                <span style="color: rgba(255,255,255,0.4); font-size: 0.8em;">${result.type}</span>
                                ${result.isRealTime ? '<span style="color: #00ff88; font-size: 0.7em;">●LIVE</span>' : '<span style="color: #ffaa00; font-size: 0.7em;">●EST</span>'}
                            </div>
                            <div class="symbol-name">${result.name}</div>
                            ${result.lastUpdate ? `<div style="color: rgba(255,255,255,0.3); font-size: 0.7em;">Updated: ${result.lastUpdate}</div>` : ''}
                        </div>
                        ${result.price ? `<div class="symbol-price">$${result.price.toFixed(result.symbol.includes('USD') && result.price < 10 ? 3 : 2)}</div>` : ''}
                    </div>
                `).join('');

                dropdown.innerHTML = html;
                dropdown.style.display = 'block';
            }

            updateSelection() {
                const dropdown = document.getElementById('autocompleteDropdown');
                const items = dropdown.querySelectorAll('.autocomplete-item');
                
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedIndex);
                });
            }

            selectSymbol(element) {
                const symbol = element.dataset.symbol;
                const name = element.dataset.name;
                const price = element.dataset.price;
                
                document.getElementById('symbolInput').value = symbol;
                
                // Auto-fill current price if available
                if (price) {
                    document.getElementById('currentPriceInput').value = price;
                }
                
                this.hideDropdown();
                
                // Focus next input
                document.getElementById('sharesInput').focus();
            }

            hideDropdown() {
                const dropdown = document.getElementById('autocompleteDropdown');
                dropdown.style.display = 'none';
                this.selectedIndex = -1;
            }

            generatePriceHistory(startPrice, endPrice, days) {
                const history = [];
                const volatility = 0.02; // 2% daily volatility
                let currentPrice = startPrice;
                
                for (let i = 0; i < days; i++) {
                    const randomChange = (Math.random() - 0.5) * 2 * volatility;
                    const trend = (endPrice - startPrice) / startPrice / days;
                    currentPrice = currentPrice * (1 + trend + randomChange);
                    
                    const date = new Date();
                    date.setDate(date.getDate() - (days - i));
                    
                    history.push({
                        date: date.toISOString().split('T')[0],
                        price: Math.max(currentPrice, 0.01)
                    });
                }
                
                // Ensure last price matches current price
                if (history.length > 0) {
                    history[history.length - 1].price = endPrice;
                }
                
                return history;
            }

            setupEventListeners() {
                document.getElementById('positionForm').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    await this.addPosition();
                });

                // Close modal on background click
                document.getElementById('positionModal').addEventListener('click', (e) => {
                    if (e.target.id === 'positionModal') {
                        this.closePositionModal();
                    }
                });
            }

            async addPosition() {
                const symbol = document.getElementById('symbolInput').value.toUpperCase();
                const shares = parseFloat(document.getElementById('sharesInput').value);
                const avgPrice = parseFloat(document.getElementById('avgPriceInput').value);
                let currentPrice = parseFloat(document.getElementById('currentPriceInput').value);

                if (!symbol || !shares || !avgPrice) {
                    alert('Please fill Symbol, Shares, and Avg Price fields');
                    return;
                }

                // If no current price provided, try to fetch it
                if (!currentPrice) {
                    try {
                        currentPrice = await this.fetchCurrentPrice(symbol);
                        if (currentPrice) {
                            document.getElementById('currentPriceInput').value = currentPrice.toFixed(2);
                        }
                    } catch (error) {
                        console.error('Price fetch error:', error);
                    }
                }

                // Use avg price as fallback if current price still not available
                if (!currentPrice) {
                    currentPrice = avgPrice;
                }

                const position = {
                    id: Date.now(),
                    symbol: symbol,
                    shares: shares,
                    avgPrice: avgPrice,
                    currentPrice: currentPrice,
                    priceHistory: this.generatePriceHistory(avgPrice, currentPrice, 30)
                };

                this.positions.push(position);
                this.savePositions();
                this.updatePortfolioMetrics();
                this.renderHoldings();
                this.setupPortfolioChart();
                this.closePositionModal();
                this.clearForm();
            }

            async fetchCurrentPrice(symbol) {
                try {
                    // Preços atualizados para Janeiro 2025
                    const predefinedPrices = {
                        'AAPL': 225.80, 'MSFT': 445.75, 'TSLA': 248.50, 'GOOGL': 185.90,
                        'AMZN': 195.25, 'NVDA': 145.60, 'META': 598.75, 'AMD': 122.30,
                        'NFLX': 895.40, 'ADBE': 485.60, 'CRM': 335.20, 'ORCL': 185.40,
                        'BTC-USD': 105750.00, 'ETH-USD': 3890.25, 'ADA-USD': 1.15, 
                        'SOL-USD': 245.80, 'DOGE-USD': 0.385, 'SPY': 598.45, 'QQQ': 525.30, 'VTI': 295.60
                    };
                    
                    // Tenta buscar preço real primeiro
                    const realPrice = await this.fetchRealTimePrice(symbol);
                    if (realPrice) {
                        return realPrice;
                    }
                    
                    // Fallback para preço base atualizado com variação
                    const basePrice = predefinedPrices[symbol];
                    if (basePrice) {
                        const variation = (Math.random() - 0.5) * 0.03; // ±1.5% variation
                        return basePrice * (1 + variation);
                    }
                    
                    return null;
                } catch (error) {
                    console.error('Error fetching price for', symbol, ':', error);
                    return null;
                }
            }

            deletePosition(id) {
                this.positions = this.positions.filter(pos => pos.id !== id);
                this.savePositions();
                this.updatePortfolioMetrics();
                this.renderHoldings();
                this.setupPortfolioChart();
            }

            clearForm() {
                document.getElementById('positionForm').reset();
            }

            savePositions() {
                localStorage.setItem('brokeragePositions', JSON.stringify(this.positions));
            }

            updatePortfolioMetrics() {
                const totalValue = this.positions.reduce((sum, pos) => sum + (pos.shares * pos.currentPrice), 0);
                const totalCost = this.positions.reduce((sum, pos) => sum + (pos.shares * pos.avgPrice), 0);
                const totalGain = totalValue - totalCost;
                const totalReturnPercent = totalCost > 0 ? ((totalGain / totalCost) * 100) : 0;

                // Simulate day change (random for demo)
                const dayChange = totalValue * (Math.random() - 0.5) * 0.02;

                document.getElementById('totalPortfolioValue').textContent = this.formatCurrency(totalValue);
                document.getElementById('portfolioChangeValue').textContent = this.formatCurrency(totalGain);
                document.getElementById('portfolioChangePercent').textContent = `${totalReturnPercent >= 0 ? '+' : ''}${totalReturnPercent.toFixed(2)}%`;
                
                // Update change indicator
                const changeIndicator = document.getElementById('portfolioChangePercent');
                changeIndicator.className = `change-indicator ${totalReturnPercent >= 0 ? 'change-positive' : 'change-negative'}`;

                document.getElementById('dayChange').textContent = this.formatCurrency(dayChange);
                document.getElementById('totalReturn').textContent = `${totalReturnPercent >= 0 ? '+' : ''}${totalReturnPercent.toFixed(2)}%`;
                document.getElementById('positionCount').textContent = this.positions.length;

                // Update metric colors
                document.getElementById('dayChange').className = `metric-value ${dayChange >= 0 ? 'profit' : 'loss'}`;
                document.getElementById('totalReturn').className = `metric-value ${totalReturnPercent >= 0 ? 'profit' : 'loss'}`;
            }

            renderHoldings() {
                const grid = document.getElementById('holdingsGrid');
                
                // Clear existing holdings (keep add button)
                const addButton = grid.querySelector('.add-position-card');
                grid.innerHTML = '';
                
                // Re-add the add button first
                if (addButton) {
                    grid.appendChild(addButton);
                }

                this.positions.forEach(position => {
                    const totalValue = position.shares * position.currentPrice;
                    const totalCost = position.shares * position.avgPrice;
                    const gainLoss = totalValue - totalCost;
                    const percentage = totalCost > 0 ? ((gainLoss / totalCost) * 100) : 0;
                    const priceChange = position.currentPrice - position.avgPrice;
                    const priceChangePercent = position.avgPrice > 0 ? ((priceChange / position.avgPrice) * 100) : 0;

                    const holdingCard = document.createElement('div');
                    holdingCard.className = 'holding-card';
                    holdingCard.innerHTML = `
                        <div class="holding-header">
                            <div class="holding-symbol">${position.symbol}</div>
                            <div class="holding-price">
                                <div class="current-price">${this.formatCurrency(position.currentPrice)}</div>
                                <div class="price-change ${priceChangePercent >= 0 ? 'profit' : 'loss'}">
                                    ${priceChangePercent >= 0 ? '+' : ''}${priceChangePercent.toFixed(2)}%
                                </div>
                            </div>
                        </div>
                        
                        <div class="holding-chart">
                            <canvas id="chart-${position.id}" width="280" height="80"></canvas>
                        </div>
                        
                        <div class="holding-details">
                            <div class="detail-item">
                                <div class="detail-label">Shares</div>
                                <div class="detail-value">${position.shares}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Avg Cost</div>
                                <div class="detail-value">${this.formatCurrency(position.avgPrice)}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Market Value</div>
                                <div class="detail-value">${this.formatCurrency(totalValue)}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">P&L</div>
                                <div class="detail-value ${percentage >= 0 ? 'profit' : 'loss'}">${this.formatCurrency(gainLoss)}</div>
                            </div>
                        </div>
                        
                        <div style="text-align: center; margin-top: 15px;">
                            <button onclick="deletePosition(${position.id})" style="
                                background: rgba(255, 51, 102, 0.1);
                                color: #ff3366;
                                border: 1px solid rgba(255, 51, 102, 0.3);
                                padding: 8px 16px;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.8em;
                                text-transform: uppercase;
                                letter-spacing: 1px;
                                transition: all 0.3s ease;
                            ">Remove</button>
                        </div>
                    `;
                    
                    grid.appendChild(holdingCard);

                    // Setup mini chart for this position
                    setTimeout(() => this.setupHoldingChart(position), 100);
                });
            }

            setupHoldingChart(position) {
                const canvas = document.getElementById(`chart-${position.id}`);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                
                const prices = position.priceHistory.map(h => h.price);
                const labels = position.priceHistory.map(h => h.date);
                
                const isPositive = position.currentPrice >= position.avgPrice;
                const color = isPositive ? '#00ff88' : '#ff3366';

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: prices,
                            borderColor: color,
                            backgroundColor: `${color}15`,
                            fill: true,
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: { display: false },
                            y: { 
                                display: false,
                                beginAtZero: false
                            }
                        },
                        elements: {
                            point: { radius: 0 }
                        },
                        interaction: {
                            intersect: false
                        }
                    }
                });
            }

            setupPortfolioChart() {
                const canvas = document.getElementById('portfolioChart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                
                // Create combined portfolio performance data
                const portfolioHistory = [];
                const days = 30;
                
                for (let i = 0; i < days; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() - (days - i));
                    
                    let totalValue = 0;
                    this.positions.forEach(position => {
                        if (position.priceHistory[i]) {
                            totalValue += position.shares * position.priceHistory[i].price;
                        }
                    });
                    
                    portfolioHistory.push({
                        date: date.toISOString().split('T')[0],
                        value: totalValue
                    });
                }

                const values = portfolioHistory.map(h => h.value);
                const labels = portfolioHistory.map(h => h.date);
                
                const startValue = values[0] || 0;
                const endValue = values[values.length - 1] || 0;
                const isPositive = endValue >= startValue;

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Portfolio Value',
                            data: values,
                            borderColor: isPositive ? '#00ff88' : '#ff3366',
                            backgroundColor: isPositive ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 51, 102, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 3,
                            pointRadius: 0,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                display: false
                            },
                            y: {
                                display: true,
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: 'rgba(255, 255, 255, 0.6)',
                                    callback: (value) => this.formatCurrency(value, true)
                                }
                            }
                        },
                        interaction: {
                            intersect: false
                        }
                    }
                });
            }

            openPositionModal() {
                document.getElementById('positionModal').style.display = 'flex';
            }

            closePositionModal() {
                document.getElementById('positionModal').style.display = 'none';
                this.clearForm();
            }

            formatCurrency(value, short = false) {
                if (short && Math.abs(value) >= 1000000) {
                    return '$' + (value / 1000000).toFixed(1) + 'M';
                } else if (short && Math.abs(value) >= 1000) {
                    return '$' + (value / 1000).toFixed(1) + 'K';
                }
                
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                }).format(value);
            }
        }

        // Global functions
        function openPositionModal() {
            window.brokerage.openPositionModal();
        }

        function closePositionModal() {
            window.brokerage.closePositionModal();
        }

        function deletePosition(id) {
            if (window.brokerage) {
                window.brokerage.deletePosition(id);
            }
        }

        function selectSymbol(element) {
            if (window.brokerage) {
                window.brokerage.selectSymbol(element);
            }
        }

        function toggleRiskAnalyzer() {
            if (window.brokerage) {
                window.brokerage.toggleRiskAnalyzer();
            }
        }

        function closeRiskAnalyzer() {
            if (window.brokerage) {
                window.brokerage.closeRiskAnalyzer();
            }
        }

        // Initialize brokerage interface
        document.addEventListener('DOMContentLoaded', function() {
            const brokerage = new BrokeragePortfolio();
            window.brokerage = brokerage;
        });
    </script>
</body>
</html>
